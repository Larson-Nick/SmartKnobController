<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Smart Knob Controller: Introduction</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Smart Knob Controller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<div id="main-nav">
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- main-nav -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('md__c_1_2_users_2nickl_2_one_drive_01-_01_cal_01_poly_2_p_o_l_y4_t_h_2_s_p_r_i_n_g_0j25_2507_2_l62e40a918e1da5f1aaf1986ec153a59b.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<div><div class="header">
  <div class="headertitle"><div class="title">Introduction </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md0"></a></p>
<p>The Smart Knob Controller is an exploration of how brushless DC motors can breathe new life into one of the most ubiquitous input devices—the humble knob—by enabling dynamic, software-configurable feedback. The result is a clean, tactile, dual-degree-of-freedom controller that feels like multiple knobs in one: snappy detents, elastic spring force, or a completely free-spinning dial. The only limit is your creativity.</p>
<p><img src="../Img/SmartKnobSketch.jpg" alt="Sketch and Render" class="inline"/></p>
<p>This project was inspired by Scott Bezek’s Smart Knob, an open-source design that garnered a strong following online. While many have used Bezek’s design as a computer input device, this project set out to explore how that same concept could enhance hardware control—specifically as a unique yet intuitive interface for my partner’s custom differential drive robot.</p>
<p>Serving as a pseudo-capstone to my undergraduate mechatronics studies at Cal Poly SLO, the Smart Knob Controller blends mechanical design, electrical hardware, embedded firmware, and control system theory—all custom designed from the ground up around an STM32 microcontroller.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md1"></a>
Electrical Hardware</h1>
<p>The Smart-Knob is centered—Iiterally and figuratively—around a custom PCB designed in KiCAD 9.0 and manufactured by JLCPCB, featuring the STM32F411CEU6 microcontroller. Code is flashed to the microcontroller through SWD using an ST-Link.</p>
<p><img src="../Img/PCB.jpg" alt="PCB Image" class="inline"/></p>
<p>At the heart of the board is a mounting surface for the GM3506 brushless gimbal motor, surrounded by cutouts that allow the PCB to flex, enabling the second degree-of-freedom. The PCB is focused on two centrally located sensors that capture each axis of input.</p>
<p>On the top center, the AS5047P magnetic rotary encoder captures the absolute angular position of the motor through a diametric encoder magnet on the center shaft of the motor. The position is read using SPI and offers 14-bit resolution. On the underside, directly opposite, the A1304 linear hall-effect sensor outputs an analog signal based on its distance away from an axial magnet fixed in the case.</p>
<p>The interaction between these two neodymium magnets was of chief concern when designing the PCB. Through clever software, detailed in the Firmware section, each was able to operate largely unaffected by the other.</p>
<p>The largest IC on the board is the DRV8313 motor driver, which receives three PWM and internally handles amplification to 12 volts as well as the MOSFET switching required to deliver properly timed signals to the three phases of the BLDC motor. The driver was selected to align with the custom commutation method devised to control the motor. <a class="el" href="class_motor.html" title="Class for 3-phase BLDC motor control using PWM and encoder feedback.">Motor</a> commutation is discussed at length in the subsequent Firmware section.</p>
<p>Powering the device through USB-C was made a priority to ensure user-friendly operation and reflect a polished product that could be envisioned in a consumer’s home. To achieve this, the CYPD3177 USB-C Power Delivery (PD) chip was used to negotiate 12V power at 1A for the motor driver. A TLV761-series LDO regulator. Power calculations confirmed the LDO would operate without excessive temperature rise.</p>
<p>The only component not integrated into the PCB is an HC-05 Bluetooth module, which is connected through UART and adhered to the bottom of the PCB. A future improvement to the PCB would certainly involve an MCU with integrated BLE.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md2"></a>
Mechanical Hardware</h1>
<p>The device is housed in a custom 3D-printed case that cleanly conceals all electronics and mounting hardware.</p>
<p><img src="../Img/ExplodedRender.png" alt="Exploded Render" class="inline"/></p>
<p>The case exposes the USB-C port for power and features a small hole for a power indication LED. The user button is hidden to preserve the clean appearance of the device but can still be actuated by lightly pressing anywhere in a large region around the LED.</p>
<p>The design of the case is only disrupted by features on the bottom necessary for prototyping. A small hole in the center allows the press-fit magnet for the hall-effect sensor to be removed, and another cutout provides access to an 8-pin header for flashing and debugging through the ST-link. These features can be easily omitted from the final case design if the product were to be fully developed.</p>
<p>Inside, a small spacer gives the motor clearance to mount above the encoder and leaves a passthrough for the motor’s JST connector, which routes through the board to the connector underneath.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md3"></a>
Firmware</h1>
<h2 class="doxsection"><a class="anchor" id="autotoc_md4"></a>
Overview</h2>
<p>The firmware for the Smart Knob Controller was developed using STM32CubeIDE in C++, organized around a finite state machine (<a class="el" href="class_f_s_m.html" title="Finite State Machine managing SmartKnob behavior and modes.">FSM</a>) architecture that runs at 100 Hz. <a class="el" href="class_motor.html" title="Class for 3-phase BLDC motor control using PWM and encoder feedback.">Motor</a> commutation is handled via timer interrupts firing at 20 kHz, enabling smooth and responsive control of the BLDC motor.</p>
<p>The codebase is built on STM32 HAL libraries, wrapped in custom C++ classes for readability and modularity. The <a class="el" href="class_f_s_m.html" title="Finite State Machine managing SmartKnob behavior and modes.">FSM</a> uses the user button to switch between modes that coordinate sensor readings, control logic, haptic feedback, and sending robot control commands.</p>
<p>At demo time, the controller supported two primary modes:</p>
<ul>
<li>Mode 1 – Elastic Knob (ADC disabled): The knob acted like a spring-loaded dial. A short press on the button toggled control between translation and rotation for the differential drive robot.</li>
<li>Mode 2 – Free-Spinning Knob (ADC enabled): A long press on the button switched to this mode, where knob rotation directly mapped to robot heading. Pulling or pressing on the knob along the axial direction (second degree of freedom) translated the robot forward or backward.</li>
</ul>
<p>Other configurations were tested during development, but these two offered the cleanest and most intuitive user experience. With more time, an additional mode was planned where the knob’s angle in free-spinning mode would correspond directly to the wheel angle—essentially turning the device into a high-fidelity, ball-mouse-style input.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md5"></a>
Custom Commutation</h2>
<p>At the heart of the Smart Knob Controller lies a custom implementation of closed-loop sinusoidal commutation—a stripped-down but highly effective take on Field-Oriented Control (FOC).</p>
<p>A 3-phase BLDC motor requires three voltage signals offset by 120°, applied in a coordinated sequence to produce continuous torque. Conventional block commutation steps through these phases abruptly, but FOC allows for much finer control by generating sinusoidal voltages aligned with the rotor’s magnetic field. This results in quieter, smoother, and more precise motion—ideal for the tactile haptics demanded by this project.</p>
<p>While traditional FOC uses current sensors for precise torque control, this implementation forgoes current feedback in favor of simplicity and speed. It’s technically "open-loop" in that sense but remains closed-loop from a position control standpoint, using real-time feedback from the encoder to drive the motor with smooth, continuous sinusoidal signals.</p>
<p>After a deep dive into academic papers and open-source implementations, I filtered the core principles of FOC into a custom control scheme that suited this hardware. The structure is outlined in the block diagram below.</p>
<p><img src="../Img/CommutationBD.png" alt="Block diagram" class="inline"/></p>
<p>The control system accepts an input called Effort—a percentage of the motor’s maximum speed, ranging from -100% to 100%. This effort value is converted into a voltage in the direct–quadrature (DQ) reference frame, where voltage in the q-axis produces maximum torque, and voltage in the d-axis produces none. As such, the input voltage vector is defined as:</p>
<p class="formulaDsp">
\[\begin{bmatrix}
v_a \\
v_b \\
v_c \\
\end{bmatrix}
=
v_d
\begin{bmatrix}
\cos(\theta_e) \\
\cos(\theta_e - 120^\circ) \\
\cos(\theta_e + 120^\circ) \\
\end{bmatrix}
+
v_q
\begin{bmatrix}
-\sin(\theta_e) \\
-\sin(\theta_e - 120^\circ) \\
-\sin(\theta_e + 120^\circ) \\
\end{bmatrix}
\]
</p>
<p>Here, the electrical angle is calculated by scaling the encoder’s mechanical angle by the number of magnetic pole pairs in the motor:</p>
<p class="formulaDsp">
\[\theta_e = \text{pole_pairs} \times \theta_m
\]
</p>
<p>This scaling ensures that the generated voltage vectors remain properly aligned with the rotor’s position, even as it rotates through multiple magnetic cycles.</p>
<p>Finally, the computed phase voltages are converted to PWM duty cycles. Since the STM32 can only output digital pulses, each phase is modulated with high-frequency PWM whose duty cycle matches the desired voltage. The motor’s inductance naturally smooths these signals, producing an average voltage that closely follows the target sine wave.</p>
<p>Observing the PWM outputs on an oscilloscope reveals their mesmerizing behavior:</p>
<p><img src="../Img/PWMCommutationGif.gif" alt="Gif of PWM signals" class="inline"/></p>
<p>When averaged over time, the signals form clean, 120°-offset sinusoidal waveforms—the hallmark of smooth, precise BLDC control:</p>
<p><img src="../Img/SinusoidalCommutation.jpg" alt="Image of sinusoidal signals" class="inline"/></p>
<p>To ensure this system ran fast enough on the STM32F411, a precomputed lookup table (LUT) was used for the cosine and sine values, indexed by the rotor angle. This eliminated the need for expensive real-time floating point operations, allowing commutation to run comfortably within a 20 kHz interrupt corresponding to the PWM timer.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md6"></a>
Haptic Control</h2>
<p>The Smart Knob Controller supports two distinct haptic behaviors: an elastic mode, where the knob feels like it’s springing back to center, and a free-spinning mode, where it rotates effortlessly with virtually no resistance.</p>
<p>In elastic mode, the controller generates a restoring torque based on a non-wrapping angular position, allowing the spring-like behavior to persist over multiple full revolutions. This non-wrapping reference makes it feel like the knob has a continuous torsion spring anchored at a moving center point. A proportional controller computes the restoring torque, which is then applied using the sinusoidal commutation system, making the response smooth and natural.</p>
<p>In free-spinning mode, the system continuously measures the angular velocity of the motor and applies a voltage based on a linear equation derived from motor characterization. This feed-forward voltage matches the back-EMF profile of the motor, effectively canceling out drag and allowing the knob to spin with even less resistance than it would when unpowered. The result is uncannily smooth, a feeling that mimics the sensation of a bearing.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md7"></a>
ADC Characterization</h2>
<p>While the two magnets for the different sensors were able to coexist on the same axis, they didn’t operate entirely independently. During testing, the <a class="el" href="class_hall.html" title="Class for reading corrected values from an ADC-based Hall effect sensor.">Hall</a> sensor output showed a position-dependent offset caused by the rotating field of the encoder magnet. To correct for this, the ADC value was recorded across a full rotation of the motor with no axial force applied. The result was a clean sinusoidal trend.</p>
<p><img src="../Img/SinusoidalRegression.png" alt="SINUSOIDAL REGRESSION PICTURE" class="inline"/></p>
<p>This data was fit with a sinusoidal regression, which produced an equation used to define a correction baseline for the Hall-effect signal. This correction curve was stored in a lookup table to avoid runtime trigonometric calculations. Every time an ADC reading was taken, the system referenced the current motor angle and subtracted the corresponding offset from the raw signal—yielding a consistent reading of the axial displacement regardless of the knobs angular position.</p>
<p>That said, the resolution wasn’t ideal. The PCB’s cutouts failed to provide as much flexibility as expected, meaning small axial movements didn’t translate to large changes in ADC values. As a result, the second degree-of-freedom control was not as high-fidelity as desired. Future revisions could benefit from a more flexible mechanical design leading to higher-resolution ADC sampling, and possibly more advanced filtering techniques to better extract the Hall-effect signal from noise.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md8"></a>
Code</h2>
<p>You can find the detailed class documentation in the <a href="classes.html">Class List</a>.</p>
<hr  />
<h1 class="doxsection"><a class="anchor" id="autotoc_md10"></a>
Demo</h1>
<hr  />
 </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
